<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: technology | Yen's Blog]]></title>
  <link href="http://dinhyen.github.io/blog/categories/technology/atom.xml" rel="self"/>
  <link href="http://dinhyen.github.io/"/>
  <updated>2019-08-09T09:53:22-04:00</updated>
  <id>http://dinhyen.github.io/</id>
  <author>
    <name><![CDATA[Yen Tran]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Installing the Curt 11064 trailer hitch on a 2009 Honda Fit Sport]]></title>
    <link href="http://dinhyen.github.io/blog/2015/04/08/installing-curt-11064-trailer-hitch-on-a-2009-honda-fit-sport/"/>
    <updated>2015-04-08T23:13:00-04:00</updated>
    <id>http://dinhyen.github.io/blog/2015/04/08/installing-curt-11064-trailer-hitch-on-a-2009-honda-fit-sport</id>
    <content type="html"><![CDATA[<p>As if that&rsquo;s not specific enough, I could also add On a Cold Sleety Night, After the Family Had Gone to Bed, While Feeling Renewed Pangs of Hunger.  I feel compelled to write this post so that Kate wouldn&rsquo;t think I spent all that time in the garage playing video games (I wish I could).  I was deciding between the Curt and a DrawTite trailer hitch.  The Curt seemed more substantial, is made in Wisconsin (the DrawTite is made in Mexico) and as it turned out is surprisingly lighter (lighter being relative, more on that later).  Installing the DrawTite requires moving the exhaust pipe out of the way, while the Curt requires drilling a hole.  The latter raises its installation difficulty to 6/10 according to a reputable web site.  I thought what the heck I could handle a drill, so I went with the Curt.  Installation should take about an hour, according to the same web site.  It ended up taking much longer than that&mdash;I won&rsquo;t say by how much because it&rsquo;s rather embarrassing, and that doesn&rsquo;t even include the amount of time buying tools online and repeated trips to the local hardware store.  I could of course have had the professionals at Rack Attack or even U-Haul do the job for reasonable cost, but that would have been a much shorter blog post.</p>

<p>Gearhead that I think I am, here&rsquo;s the list of tools I used with varying degrees of competency and success:</p>

<ul>
<li>Rhino ramps</li>
<li>Large garden stone masquerading as wheel chock</li>
<li>Heavy-duty Milwaukee &frac12;" &ldquo;Hole Shooter&rdquo; drill</li>
<li>17/32" black oxide drill bit, &frac12;" drive</li>
<li>Tree-shaped tungsten carbide burr bit</li>
<li>Torque wrench, up to 150 lb-ft, &frac12;" drive</li>
<li>&frac34;" socket, &frac12;" drive</li>
<li>&frac12;" drive extension rod</li>
<li>Wire guide</li>
<li>Regular cordless drill</li>
<li>Assorted screwdrivers</li>
<li>Pair of pliers</li>
<li>Silicone lubricant</li>
<li>Blocks of wood (as headrest)</li>
<li>Bunch of collapsed cardboard boxes to lie on</li>
<li>Wearable LED head lamp</li>
<li>Sharpie permanent marker</li>
<li>iPhone (to take picture and record video)</li>
</ul>


<p>Here&rsquo;s the executive summary: make sure you remove the plastic cover immediately aft of the rear wheelwell on the driver side.  Then feel free to skip the rest of this post.</p>

<p>The helpful <a href="https://www.etrailer.com/tv-install-trailer-hitch-2012-honda-fit-11064.aspx">installation video</a> seemed easy enough.  The lack of swearing had me feeling optimistic.  After I had the car on the ramps and all the tools assembled, things started off pretty well.  The most difficult part was &ldquo;hanging&rdquo; the hitch in place so that I could use it as a template to mark the hole to drill on the driver side.  It was difficult because I had to hold the hitch with one hand while tightening the nut with the other, and there was little wiggle room.  I ended up supporting the hitch with my knee on one end and shoulder/forearm on the other; if it were a yoga pose it would be name &ldquo;opossum faking death&rdquo;.  It wasn&rsquo;t pretty or doctor-approved but it worked.  Drilling the hole was challenging too because the &ldquo;Hole Shooter&rdquo; weighs like a mini-hitch; they do not make things light in Wisconsin.  The video mentioned enlarging the drilled hole so that the bulky spacer can be pushed through.  I had read elsewhere that instead the adjacent pre-drilled hole could be used with a wire guide to pull the spacer and bolt through.  As a test, I was able to get the wire guide through, so this seemed promising.  The hole was just a tad smaller than the spacer, so I went to the hardware store to get the burr bit; this wasn&rsquo;t a wasted trip as I had to return the rental &ldquo;Hole Shooter&rdquo;.  I was tempted to go with a tapered file rather than the burr bit, but luckily I didn&rsquo;t or I wouldn&rsquo;t be writing this until tomorrow at the earliest.  Anyways, after enlarging the hole, the spacer fit but seemed to be too long to go through.  I dutifully enlarged the hole further until it could fit through.  Light at the end of the tunnel, literally.  But lo and behold, as I tried to pull it through with the wire guide, something blocked its way.  So now the spacer was completely in the whole, but stuck.  I had visions of the spacer rattling inside the frame tube for the next few years as I drive down the road, hitch-less.  Finally, with the help of screwdriver to nudge the spacer and push it up through another, smaller hole, and a pair of pliers to grab it by the end, I was able to extract the spacer.  I peeped through the hole and was able to to make out a semi-circular opening between it and the hole I drilled.  The opening must not have been large enough for the spacer to fit, and definitely not for the bolt.  That&rsquo;s the last time I listen to an Internet advice!  Well, maybe.  So now back to the pre-shortcut plan of enlarging the drilled hole.  To make more room, I decided to completely remove the plastic cover.</p>

<p>You see, I had only loosened the cover and pushed it out of the way to access the pre-drilled hole.  I violated my own rule of &ldquo;never take shortcuts&rdquo;.  Removing it wasn&rsquo;t hard, just pop open 2-4 plastic fasteners and 2 screws.  Once the cover was off, I looked around and discovered to my amazement that there was a large rearward opening the into compartment I was trying so hard to get into!  It WAS possible to come in through the South Entrance.  Afterward it took me about 10 seconds to get the bolt and spacer in place.</p>

<p>This video shows the opening relative to the drilled hole.</p>

<iframe src="http://www.youtube.com/embed/AFs9emotQQg?modestbranding=1" allowfullscreen="true" height="400px" width="100%"></iframe>


<p>Here&rsquo;s the view from below.</p>

<p><img src="http://yentran.isamonkey.org/gallery/curt-hitch/curt-hitch-access.jpg" alt="" /></p>

<p>I took this video by sticking the headlight into the opening, then inserting the iPhone right above it.  As you can see, there was no way that anything could have been pulled through that semi-circular opening.  Overzealous googling led me through a wild goose chase.</p>

<iframe src="http://www.youtube.com/embed/XC3CNcJDP1U?modestbranding=1" allowfullscreen="true" height="400px" width="100%"></iframe>


<p>The hitch is finally in place and we are in business.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to not upgrade the Nexus 7 to Lollipop]]></title>
    <link href="http://dinhyen.github.io/blog/2015/02/16/how-to-not-upgrade-the-nexus-7-to-lollipop/"/>
    <updated>2015-02-16T00:00:00-05:00</updated>
    <id>http://dinhyen.github.io/blog/2015/02/16/how-to-not-upgrade-the-nexus-7-to-lollipop</id>
    <content type="html"><![CDATA[<p>I have a first-generation Nexus 7 tablet made by Asus which ran KitKat 4.4.  When the OTA Lollipop update became available, I couldn&rsquo;t wait to install it.  The latest and greatest Android running on Google hardware seemed to be a match made in heaven; it would be better, prettier and faster, right?  As you can probably guess from the title of this post, the answer was a resounding <em>no</em>.  Everything became sluggish, swipes would only registered after a couple of seconds, random things popped open and close.  The tablet was downright unusable.</p>

<p>Rather than splurging for a new tablet, which was probably what Google wanted me to do, I opted to go back to KitKat, since the hardware itself was perfectly fine.  The <a href="https://developers.google.com/android/nexus/images">process to restore the KitKat system image</a> using the ADB command-line tool that accompanies the Android SDK was quite simple.  I had some difficulty to get my Windows 7 machine to recognize the Nexus 7, until I installed the <a href="http://developer.android.com/sdk/win-usb.html">Google USB drivers</a>.  Alternatively, I could have ran ADB on a Mac, for which USB drivers wouldn&rsquo;t have been necessary.  An important part of the process was to make sure I chose the correct system image.  For a Nexus 7, the KitKat image was &ldquo;nakasi&rdquo; 4.4.4 (KTU84P).  The image archive contained a flashing script that I executed after unlocking the bootloader.  The whole thing took about 5 minutes once everything worked.</p>

<p>So with its brain transplanted with a fresh KitKat image, the Nexus was back to its own happy self.  Unfortunately, the good feeling didn&rsquo;t last long.  In short order, Android started notifying me that the 5.0 system update aka Lollipop had <em>already</em> been downloaded and ready to install.  There was no way to dismiss the notification or tell it to remind me again in, oh, never.  The helpful notification sat in the system tray and just generally got in the way.  This is by far one of the worst instances of nagware-ism.</p>

<p>To disable the system update notification, I had to root Android.  Fortunately at this point there were a few mature tools that make doing so quite simple.  I used the <a href="http://www.wugfresh.com/nrt">Nexus Root Toolkit 2.0.4</a>.  Since I was on a fresh install of KitKat, all I had to do was to 1) unlock the bootloader, and 2) root.  The toolkit also installs a couple of useful tool such as SuperSU and BusyBox Installer.  The latter lets you grant root privilege on-demand to any app that requests it.</p>

<p>The next step was to turn off the system update notification service.  There are a few apps, the one I used being DisableService.  Once I navigated to the Google System Service node, System Update Service was already disabled.  Hmm, clearly that wasn&rsquo;t it because there was still a big fat notification in the system tray.  It turned out that I had to go to the Google Play Services node.  Lo and behold, there was another System Update Service.  Disabling this one and restarting the device did the trick.</p>

<p><img src="http://yentran.isamonkey.org/gallery/nexus-7-kitkat/disable-service.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Validating multiple fields with Angular]]></title>
    <link href="http://dinhyen.github.io/blog/2014/07/09/validating-multiple-fields-with-angular/"/>
    <updated>2014-07-09T16:52:00-04:00</updated>
    <id>http://dinhyen.github.io/blog/2014/07/09/validating-multiple-fields-with-angular</id>
    <content type="html"><![CDATA[<p>Angular makes it simple to validate a single form field.  Validating multiple fields requires a bit more work.  The approach that works for me is use a directive to lay out the framework, but to perform the actual validation in the parent scope.  Since the user defines the specifics of the validation, any arbitrary validation can be performed and the directive can be kept simple.</p>

<p>In this example, I&rsquo;d like to validate that the sum of 2 text inputs equals 10.  I would specify that the validation should be performed via the <code>multi</code> directive, which also specifies the custom validation function from the parent scope.</p>

<p>```
<form name="form" novalidate>
  <p></p>

<pre><code>&lt;input type="text" name="field1" ng-model="field1" multi="validateSum" /&gt;
&lt;span ng-show="form.field1.$error.multi"&gt;Must add up to 10&lt;/span&gt;
</code></pre>

<p>  </p>
  <p></p>

<pre><code>&lt;input type="text" name="field2" ng-model="field2" multi="validateSum" /&gt;
&lt;span ng-show="form.field2.$error.multi"&gt;Must add up to 10&lt;/span&gt;
</code></pre>

<p>  </p>
</form>
```</p>

<p>The <code>validateSum</code> function should return true (valid) if the sum of the 2 fields equals 10, or if any of the fields is empty.</p>

<p>```
$scope.validateSum = function () {
  if ($scope.field1 !== null &amp;&amp; $scope.field2 !== null) {</p>

<pre><code>return parseFloat($scope.field1) + parseFloat($scope.field2) === 10;
</code></pre>

<p>  } else {</p>

<pre><code>return true;
</code></pre>

<p>  }
};
```</p>

<p>The directive specifies the validation function as a value of the <code>multi</code> attribute: <code>multi="validateSum"</code>.  This isn&rsquo;t quite idiomatic for Angular.  The preferred alternative is probably to create an isolate scope for the directive and pass in the function via <code>&amp;</code> or <code>&amp;anotherAttribute</code>.  I just think providing the external function as the value of the directive&rsquo;s attribute is cleaner and more succinct.  However, this approach requires a bit of extra handling in the directive&rsquo;s postlink function:</p>

<p><code>
 var validate = $parse(attrs.multi)(scope);
</code></p>

<p>The <code>$parse</code> service evaluates the value of <code>attrs.multi</code>, which is the string <code>validateSum</code>, in the context of the directive&rsquo;s scope.  Essentially this gives us the reference to <code>scope.validateSum</code>, which is created automatically by Angular and points to the function defined in the parent scope.</p>

<p>In order to work properly with Angular&rsquo;s form validation, the directive integrates with Angular&rsquo;s <code>ngModel</code> directive.  This is specified with <code>require: 'ngModel'</code> in the directive definition object.  Once this is done, the model&rsquo;s controller is provided as a 4th parameter to the directive&rsquo;s postlink function.</p>

<p>When the user changes the value of an input, we should perform the validation.  If the validation fails, the model should be marked as invalid, which results in the form being invalid, and we can display an error message and prevent the form from being submitted.  This is as simple as calling <code>ngModelController.$setValidity</code>:</p>

<p><code>
ngModelCtrl.$viewChangeListeners.push(function () {
  ngModelCtrl.$setValidity('multi', validate());
});
</code></p>

<p>Calling <code>validate()</code> would invoke <code>scope.validateSum()</code> which would invoke <code>validateSum()</code> in the parent scope to perform the actual validation.  Note that validation is performed only after a change has been made, so any existing model value wouldn&rsquo;t be validated.</p>

<p>Any key can be used with <code>$setValidity</code>, in this case <code>multi</code>.  If the input is invalid, the special error object <code>formName.inputName.$error</code> would become <code>{ multi: true }</code>.  We can key on the presence of the <code>multi</code> property to manually display an error message, or use <a href="https://docs.angularjs.org/api/ngMessages/directive/ngMessages">ngMessages</a>.</p>

<p>When the user changes an input, we should validate it and related inputs, as the overall validity depends on all inputs.  Since the inputs could be anywhere in the DOM, I figured the best way to notify all inputs is to use a root scope broadcast.  Since the input which triggers the event would also handle it, it&rsquo;s sufficient to just triggers the event in the change handler and validate in the broadcast handler.</p>

<p>```
scope.$on(&lsquo;multi:valueChanged&rsquo;, function (event) {
  ngModelCtrl.$setValidity(&lsquo;multi&rsquo;, validate());
});</p>

<p>ngModelCtrl.$viewChangeListeners.push(function () {
  $rootScope.$broadcast(&lsquo;multi:valueChanged&rsquo;);
});
```</p>

<p>This is the directive in its entirety:
```
app.directive(&lsquo;multi&rsquo;, [&lsquo;$parse&rsquo;, &lsquo;$rootScope&rsquo;, function ($parse, $rootScope) {
  return {</p>

<pre><code>restrict: 'A',
require: 'ngModel',
link: function (scope, elem, attrs, ngModelCtrl) {
  var validate = $parse(attrs.multi)(scope);

  ngModelCtrl.$viewChangeListeners.push(function () {
    // ngModelCtrl.$setValidity('multi', validate());
    $rootScope.$broadcast('multi:valueChanged');
  });

  var deregisterListener = scope.$on('multi:valueChanged', function (event) {
    ngModelCtrl.$setValidity('multi', validate());
  });
  scope.$on('$destroy', deregisterListener); // optional, only required for $rootScope.$on
}
</code></pre>

<p>  };
}]);
```
And there you have it.</p>

<p>Here&rsquo;s the <a href="http://plnkr.co/edit/BHnxxKhhP0xG96MekAtr">plunk</a>;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Validating required form fields with Angular]]></title>
    <link href="http://dinhyen.github.io/blog/2014/04/24/validating-required-form-fields-with-angular/"/>
    <updated>2014-04-24T13:33:00-04:00</updated>
    <id>http://dinhyen.github.io/blog/2014/04/24/validating-required-form-fields-with-angular</id>
    <content type="html"><![CDATA[<p>Two things can happen when the user fills out a form field: the entered value is incorrect or the value is missing.  With Angular validating either case is consistent and simple.  The issue is when to show the error message: as the value is being entered, after the field loses focus or after the user submits the form.  I think that for a better usability, the user should be informed that the value is incorrect while entering the value.  This way the user isn&rsquo;t forced to scan the form to locate the problem.  If the user makes a mistake, it&rsquo;s more convenient to be able to fix it while already editing the field.  And we also take full advantage of Angular&rsquo;s instant update.  This approach works well for validating whether a value is correct.</p>

<p>However validating a required field is different.  We don&rsquo;t know if a value is missing until the user submits the form.  So to handle both scenarios, we should be able to display an error message as the user enters a value and after the user submits the form.</p>

<p>Before Angular 1.3, showing an error message requires some logic based on field statuses such as invalid or dirty.  With Angular 1.3 and later, we can use the new <code>ngMessages</code> directive to show an error message only when it is present.  Take as an example the following text field:</p>

<p><code>html
&lt;input type="text" name="name" required ng-maxlength="5"&gt;
</code></p>

<p>Following is how we can display an instantaneous error message as soon as the max length is exceeded.  If this is the case, the <code>form.name.$error</code> property would have the value <code>"$error":{"maxlength":true}</code> and only the <code>span</code> for <code>maxlength</code> would be displayed.  Only one error message would be displayed at a time.  If there are multiple matches, for example <code>maxlength</code> and <code>pattern</code>, I believe the one which appears earliest would be used.</p>

<p>``` html</p>

<div ng-messages="form.name.$error" class="help-block">
  <span ng-message="maxlength">max length 5</span>
</div>


<p>```</p>

<p>To display an error message for missing value, unfortunately, still relies on a flag for whether the form is submitted.  This would be shown after the user submits the form.
``` html</p>

<div ng-show="form.$submitted" ng-messages="form.name.$error" class="help-block">
  <span ng-message="required">required</span>
</div>


<p>```</p>

<p>Finally, we can apply a CSS class to the container when an error condition exists; i.e., when the field contains an invalid value and either the field has been modified (dirty) or the form has been submitted.  Because the field is required, it is already invalid from the start, so the additional checks ensure that we don&rsquo;t apply the error styling right off the bat, which would be a disconcerting experience.  We&rsquo;re using Bootstrap which has a class, <code>.has-error</code>, which applies red text and border to labels, inputs and help blocks.</p>

<p>``` html</p>

<div class="form-group" ng-class="{'has-error':form.name.$invalid && (form.name.$dirty || form.$submitted)}">
</div>


<p>```</p>

<p>Here&rsquo;s the <a href="http://plnkr.co/edit/bB8mGsX6bHMZu4SvfCA2">plunk</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Angular in Jekyll/Octopress]]></title>
    <link href="http://dinhyen.github.io/blog/2014/04/18/angular-in-jekyll-or-octopress/"/>
    <updated>2014-04-18T00:00:00-04:00</updated>
    <id>http://dinhyen.github.io/blog/2014/04/18/angular-in-jekyll-or-octopress</id>
    <content type="html"><![CDATA[<p>Have a problem with Angular scope variable binding not working on a Jekyll or Octopress (which uses Jekyll) page?  It so happens that Jekyll&rsquo;s Liquid Template uses the same  syntax as Angular and would attempt to process the markup before Angular can get to it.  To get around the problem, you can surround Angular markup with <code>&#123;% raw %&#125;</code> and <code>&#123;% endraw %&#125;</code> tags.  Alternatively, you can also forgo from using this syntax altogether and use Angular&rsquo;s <code>ng-bind</code> directive to bind a variable to a DOM element.</p>
]]></content>
  </entry>
  
</feed>
