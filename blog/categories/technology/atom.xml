<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: technology | Yen's Blog]]></title>
  <link href="http://dinhyen.github.io/blog/categories/technology/atom.xml" rel="self"/>
  <link href="http://dinhyen.github.io/"/>
  <updated>2014-04-03T17:47:14-04:00</updated>
  <id>http://dinhyen.github.io/</id>
  <author>
    <name><![CDATA[Yen Tran]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Simple tasks with Grunt]]></title>
    <link href="http://dinhyen.github.io/blog/2014/03/03/simple-tasks-with-grunt/"/>
    <updated>2014-03-03T15:16:00-05:00</updated>
    <id>http://dinhyen.github.io/blog/2014/03/03/simple-tasks-with-grunt</id>
    <content type="html"><![CDATA[<p>Developers are lazy by nature and always look for ways to avoid having to perform repetitive tasks. There are plenty of options when you&rsquo;re working with conventional server-side platforms.  Unfortunately, when it comes to JavaScripts and CSS, automation tools are harder to find. That is, until Grunt comes along (following Node, which turned upside down the whole idea of server vs client side in the first place).</p>

<p>As a self-described &ldquo;task runner&rdquo;, Grunt is powerful and pleasantly approachable.  Its succinctness makes it a joy to use.  This carries over into the Grunt documentation, which is really excellent.  Inspired by the <a href="http://gruntjs.com/sample-gruntfile">Sample Gruntfile tutorial</a>, I&rsquo;d like to walk through my own <code>Gruntfile</code> created for a <a href="https://github.com/dinhyen/darkbox">small JavaScript library</a>.  The goal is to automate a typical process of building the app, from generating CSS from Sass, aggregating various source files into a single file, and minifying the result.</p>

<p>Once you <a href="http://gruntjs.com/installing-grunt">have Grunt installed</a> using the Node Package Manager, you will need a <code>package.json</code> file, just as for other Node utilities.  The quickest way to create a <code>package.json</code> file is to simply run <code>npm init</code> which generates the file after a series of questions.</p>

<p>The following libraries will be used:</p>

<ul>
<li><a href="https://github.com/gruntjs/grunt-contrib-compass">grunt-contrib-compass</a>: generates CSS from Sass</li>
<li><a href="https://github.com/gruntjs/grunt-contrib-concat">grunt-contrib-concat</a>: combines various files into a single file</li>
<li><a href="https://github.com/gruntjs/grunt-contrib-cssmin">grunt-contrib-cssmin</a>: minifies CSS</li>
<li><a href="https://github.com/gruntjs/grunt-contrib-jshint">grunt-contrib-jshint</a>: combs through JavaScript and flags errors or usage issues</li>
<li><a href="https://github.com/gruntjs/grunt-contrib-uglify">grunt-contrib-uglify</a>: mangles and minifies JavaScript</li>
<li><a href="https://github.com/gruntjs/grunt-contrib-watch">grunt-contrib-watch</a>: performs tasks whenever a file changes</li>
</ul>


<p>The recommended approach, as stated at the beginning of the documentation for each plugin, is to run <code>npm install grunt-contrib-xxx --save-dev</code>, which has the dual benefit of installing the plugin and also adding a reference to it in <code>package.json</code>.</p>

<p>Besides <code>package.json</code>, the only other file you need is <code>Gruntfile</code>, in which you define and configure the tasks to run. Configuration options are specified as the argument to <code>grunt.initConfig</code>.</p>

<p>The first line reads in <code>package.json</code> and turns it into an object.  In this case, I&rsquo;m interested in product name, but it can provide <a href="http://package.json.nodejitsu.com">many other useful properties</a>.</p>

<p><code>javascript
pkg: grunt.file.readJSON('package.json'),
</code></p>

<p>All <code>Gruntfile</code> tasks share the <a href="http://gruntjs.com/configuring-tasks">same basic syntax</a> for specifying options, input and output.  Each task&rsquo;s configuration block is named after the plugin; for example, the configuration block for the <code>grunt-contrib-uglify</code> is simply <code>uglify</code>.  Each task can have arbitrary targets.  You&rsquo;ll probably see a &ldquo;test&rdquo; target for testing or a &ldquo;dist&rdquo; target for building a distribution.  Since I want to build CSS and JavaScript, here I have 2 targets, &ldquo;scripts&rdquo; and &ldquo;stylesheets&rdquo;.  When there are multiple targets in a task, each target can be executed directly.  For example, <code>grunt concat:scripts</code> runs just the &ldquo;scripts&rdquo; target.  If you don&rsquo;t provide a target, then all targets would be run in order.</p>

<p>The Compass task generates CSS from Sass source.  Of course, Compass <a href="http://compass-style.org/install">must be installed</a> first.  The following options simply instruct Compass to process Sass files in the directory &ldquo;sass&rdquo; and generate the corresponding CSS files in the directory &ldquo;css&rdquo;.
``` javascript
compass: {
  stylesheets: {</p>

<pre><code>options: {
  sassDir: 'sass',
  cssDir: 'css'
}
</code></pre>

<p>  }
}
```</p>

<p>When developing, it would be nice to be able to preview changes made to the Sass source.  This is where the watch plugin comes in.  In the simplest use case it simply detects that one or more files have been changed and then runs certain tasks.  The following options allow me to re-generate CSS each time a Sass file is modified.  Start watching by typing <code>grunt watch</code> at the command prompt.</p>

<p>``` javascript
watch: {
  stylesheets: {</p>

<pre><code>files: '**/*.scss',
tasks: ['compass']
</code></pre>

<p>  }
}
```</p>

<p>Typically JavaScript and CSS source is distributed over multiple files.  In production you&rsquo;d want to combine the various source files into a single file for performance reason.  This can be done with the concat plugin.  For the source, I&rsquo;m using a globbing pattern for simplicity; <code>src/**/*.js</code> means all <code>.js</code> files in the <code>src</code> directory and any of its sub-directories.  The files would be combined in alphabetical order. An alternative would be to specify an array of individual files.  While this lets you control the ordering of files, it becomes unwieldy for a large number of files. Of course, there are <a href="http://gruntjs.com/configuring-tasks#globbing-patterns">many ways</a> to skin the cat.  For the output, I&rsquo;m using the project&rsquo;s name which comes from <code>package.json</code>.</p>

<p>``` javascript
concat: {
  scripts: {</p>

<pre><code>options: {
  separator: ';'
},
src: 'src/**/*.js',
dest: 'dist/&lt;%= pkg.name %&gt;.js'
</code></pre>

<p>  },
  stylesheets: {</p>

<pre><code>src: 'css/**/*.css',
dest: 'dist/&lt;%= pkg.name %&gt;.css'
</code></pre>

<p>  }
}
```</p>

<p>The cssmin plugin provides CSS minification.  The source should be the output of the concat stage.  Note the variable substitution syntax.</p>

<p>``` javascript
cssmin: {
  stylesheets: {</p>

<pre><code>src: '&lt;%= concat.stylesheets.dest %&gt;',
dest: 'dist/&lt;%= pkg.name %&gt;.min.css'
</code></pre>

<p>  }
}
```</p>

<p>The uglify plugin is the JavaScript equivalent of cssmin.  It also mangles variable names which reduces file size further at the expense of readability.  Since mangling pretty much makes your JavaScript indecipherable and impossible to debug, you can also provide a <a href="http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/">source map</a> which lets you view the original, non-uglified source when debugging.  The uglify plugin have all these and sundry options.  Here it also inserts a comment with some basic information at the top of the file.</p>

<p>``` javascript
uglify: {
  options: {</p>

<pre><code>banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("yyyy-mm-dd") %&gt; */\n',
sourceMap: true
</code></pre>

<p>  },
  scripts: {</p>

<pre><code>src: '&lt;%= concat.scripts.dest %&gt;',
dest: 'dist/&lt;%= pkg.name %&gt;.min.js'
</code></pre>

<p>  }
}
```</p>

<p>The jshint configuration block just sets some <a href="http://www.jshint.com/docs/options">options for jshint</a>.
``` javascript
jshint: {
  options: {</p>

<pre><code>curly: true,
eqeqeq: true,
immed: true,
latedef: true,
newcap: true,
noarg: true,
sub: true,
undef: true,
unused: true,
boss: true,
eqnull: true,
node: true
</code></pre>

<p>  }
```</p>

<p>Finally register a default task and a useful task.  Tasks would be executed in the order specified.
<code>javascript
grunt.registerTask('default', ['jshint', 'compass', 'concat', 'cssmin', 'uglify']);
grunt.registerTask('sassify', ['compass']);
</code></p>

<p>To run a task, simply specify the task&rsquo;s name as a argument to <code>grunt</code> on the command line; e.g., <code>grunt jshint</code>.  Simply typing <code>grunt</code> runs the default task.  Below is the output for running the default task; even for this small set of tasks, running them manually or maintaining a script without Grunt would have been a tedious chore.</p>

<p>```
Running &ldquo;jshint:scripts&rdquo; (jshint) task</p>

<blockquote><blockquote><p>2 files lint free.</p></blockquote></blockquote>

<p>Running &ldquo;compass:stylesheets&rdquo; (compass) task
unchanged sass/darkbox.scss
unchanged sass/mixins.scss
unchanged sass/screen.scss
Compilation took 0.012s</p>

<p>Running &ldquo;concat:scripts&rdquo; (concat) task
File dist/darkbox.js created.</p>

<p>Running &ldquo;concat:stylesheets&rdquo; (concat) task
File dist/darkbox.css created.</p>

<p>Running &ldquo;cssmin:stylesheets&rdquo; (cssmin) task
File dist/darkbox.min.css created: 3.9 kB → 2.78 kB</p>

<p>Running &ldquo;uglify:scripts&rdquo; (uglify) task
File dist/darkbox.min.map created (source map).
File dist/darkbox.min.js created: 5.45 kB → 2.51 kB</p>

<p>Done, without errors.
```</p>

<p>Below is the entire <code>Gruntfile</code>.  Happy grunting.</p>

<p>``` javascript
module.exports = function (grunt) {</p>

<p>  grunt.initConfig({</p>

<pre><code>pkg: grunt.file.readJSON('package.json'),
compass: {
  stylesheets: {
    options: {
      sassDir: 'sass',
      cssDir: 'css'
    }
  }
},
concat: {
  scripts: {
    options: {
      separator: ';'
    },
    src: 'src/**/*.js',
    dest: 'dist/&lt;%= pkg.name %&gt;.js'
  },
  stylesheets: {
    src: 'css/**/*.css',
    dest: 'dist/&lt;%= pkg.name %&gt;.css'
  }
},
cssmin: {
  stylesheets: {
    src: '&lt;%= concat.stylesheets.dest %&gt;',
    dest: 'dist/&lt;%= pkg.name %&gt;.min.css'
  }
},
jshint: {
  options: {
    curly: true,
    eqeqeq: true,
    immed: true,
    latedef: true,
    newcap: true,
    noarg: true,
    sub: true,
    undef: true,
    unused: true,
    boss: true,
    eqnull: true,
    node: true
  },
  scripts: {
    src: ['Gruntfile.js', 'src/*.js']
  }
},
uglify: {
  options: {
    banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("yyyy-mm-dd") %&gt; */\n',
    sourceMap: true
  },
  scripts: {
    src: '&lt;%= concat.scripts.dest %&gt;',
    dest: 'dist/&lt;%= pkg.name %&gt;.min.js'
  }
},
watch: {
  stylesheets: {
    files: '**/*.scss',
    tasks: ['compass']
  }
}
</code></pre>

<p>  });</p>

<p>  grunt.loadNpmTasks(&lsquo;grunt-contrib-compass&rsquo;);
  grunt.loadNpmTasks(&lsquo;grunt-contrib-concat&rsquo;);
  grunt.loadNpmTasks(&lsquo;grunt-contrib-cssmin&rsquo;);
  grunt.loadNpmTasks(&lsquo;grunt-contrib-jshint&rsquo;);
  grunt.loadNpmTasks(&lsquo;grunt-contrib-uglify&rsquo;);
  grunt.loadNpmTasks(&lsquo;grunt-contrib-watch&rsquo;);</p>

<p>  grunt.registerTask(&lsquo;default&rsquo;, [&lsquo;jshint&rsquo;, &lsquo;compass&rsquo;, &lsquo;concat&rsquo;, &lsquo;cssmin&rsquo;, &lsquo;uglify&rsquo;]);
  grunt.registerTask(&lsquo;sassify&rsquo;, [&lsquo;compass&rsquo;]);
};
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My Git cheat sheet]]></title>
    <link href="http://dinhyen.github.io/blog/2014/02/07/my-git-cheat-sheet/"/>
    <updated>2014-02-07T16:02:00-05:00</updated>
    <id>http://dinhyen.github.io/blog/2014/02/07/my-git-cheat-sheet</id>
    <content type="html"><![CDATA[<p>There are lots of great Git guides out there.  This is intended simply to be a reference for me during those dark times when I can&rsquo;t remember the syntax for creating a tracking branch.</p>

<h3>Config</h3>

<p>```</p>

<h1>These will show up in git log</h1>

<p>git config &mdash;global user.name &ldquo;Yen Tran&rdquo;
git config &mdash;global user.email <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#x79;&#x65;&#x6e;&#64;&#121;&#x65;&#x6e;&#x74;&#114;&#97;&#x6e;&#46;&#x6f;&#x72;&#103;">&#x79;&#101;&#x6e;&#x40;&#121;&#101;&#x6e;&#116;&#114;&#x61;&#110;&#x2e;&#111;&#114;&#103;</a>
git config &mdash;list
```</p>

<h3>Info</h3>

<p>```
gitk
git status
git log
git log origin/master</p>

<h1>Show endpoints such as origin</h1>

<p>git remote show</p>

<h1>Show origin params</h1>

<p>git remote show origin
```</p>

<h3>Branch (Local)</h3>

<p>```
git branch <branch> &lt;sha1_of_commit></p>

<h1>Ex: git branch foo 7e2785d</h1>

<p>```</p>

<p>```</p>

<h1>Delete branch</h1>

<p>git branch -d <branch></p>

<h1>Create branch:</h1>

<p>git branch <branch>
git checkout <branch></p>

<h1>Check out and automatically creates branch</h1>

<p>git checkout -b <branch></p>

<h1>List local branches</h1>

<p>git br</p>

<h1>List remote branches</h1>

<p>git branch -r</p>

<h1>List all branches</h1>

<p>git branch -a</p>

<h1>Verbose list of local branches and HEAD commit</h1>

<p>git branch -v
```</p>

<h3>Check out a previous check-in</h3>

<p>```
git log</p>

<h1>Locate desired checkin and copy SHA; e.g., f2bc540fc6817b0409571f6e5a562dffa6396017</h1>

<p>git checkout <SHA></p>

<h1>Do stuff, publish, etc.</h1>

<p>git checkout master
```</p>

<h3>Cherry-pick</h3>

<p>```</p>

<h1>Source branch</h1>

<p>git co 2012-01-01-A</p>

<h1>Get top log entry</h1>

<p>git log -1</p>

<h1>Copy first few characters of SHA hash</h1>

<h1>Destination branch</h1>

<p>git co master
git cherry-pick 96f39d92de93</p>

<h1>Review changes</h1>

<p>git diff HEAD~1
```</p>

<h3>Clone</h3>

<p>```</p>

<h1>SSH keys under ~/.ssh</h1>

<p>git clone git@donny:repo.git</p>

<h1>Directory is optional; automatically created if not specified</h1>

<p>git clone gitolite@donny:repo.git [directory]
```</p>

<h3>Commit</h3>

<p>```</p>

<h1>Also automatically stage and commit</h1>

<p>git commit -a -m &ldquo;commit message here&rdquo;</p>

<h1>Add to previous commit or Rename a commit message</h1>

<p>git commit &mdash;amend</p>

<h1>Select reword for the desired commit in the interactive editor</h1>

<h1>Edit the message</h1>

<h1>Save</h1>

<p>git rebase -i master
```</p>

<h3>Create new repo</h3>

<p>```
git init</p>

<h1>So that subsequent add can ignore files</h1>

<p>git add .gitignore
git remote add origin git@donny:repo.git
git remote add origin git@github.com:user/repo.git</p>

<h1>add and commit files (-u option updates local)</h1>

<p>git push -u origin master
```</p>

<h3>Diff</h3>

<p>```</p>

<h1>Graphical version</h1>

<p>git difftool
git diff <directory>
git difftool HEAD~1</p>

<h1>Diff files that have been staged</h1>

<p>git diff &mdash;cached</p>

<h1>Diff local changes against repository</h1>

<p>git diff origin/master
```</p>

<h3>Help</h3>

<p>```
man git-log
man git-show</p>

<h1>etc.</h1>

<p>```</p>

<h3>Log</h3>

<p>```</p>

<h1>Get top 1 log entry</h1>

<p>git log -1</p>

<h1>Show history beyond renames</h1>

<p>git log &mdash;follow file</p>

<h1>Include diffs</h1>

<p>git log -p file
```</p>

<h3>Stage</h3>

<p>```
git add <file>&hellip;
git add .</p>

<h1>Opposite of add; use when files are renamed, etc.</h1>

<p>git rm <file>&hellip;
```</p>

<h3>Stash</h3>

<p>```
git stash
git stash list</p>

<h1>Show changes in stash, where 0 is the number of the stashed item as shown by git stash list</h1>

<p>git show @{0}</p>

<h1>Drop specified stash where xx is number shown in stash list</h1>

<p>git stash drop stash@{xx}
```</p>

<h3>Drop local changes</h3>

<p>```</p>

<h1>Change state of working copy to match repository, if file has not been added to index/staging</h1>

<p>git checkout &mdash; <filename></p>

<h1>Ditto, but if file has been added to index</h1>

<p>git reset <filename>
git stash save &mdash;keep-index
```</p>

<h3>Pull</h3>

<p><code>
git pull origin master
git checkout master
</code></p>

<h3>Rebase: resolve conflict</h3>

<p>```
git checkout <branch>
git rebase master
git status
git add <file></p>

<h1>Fix conflicts</h1>

<p>git rebase &mdash;continue
```</p>

<h3>Rebase: interactive</h3>

<p>```
git rebase -i origin/master
git rebase -i</p>

<h1>In the text editor, select s or squash on the bottom-most commits to squash them</h1>

<p>```</p>

<h3>Refs</h3>

<p>You may get this error when running &ldquo;git branch -d foo&rdquo;:
warning: deleting branch &lsquo;foo&rsquo; that has been merged to &lsquo;refs/remotes/origin/foo&rsquo;, but not yet merged to HEAD.
Deleted branch foo (was 334730a).
From <a href="http://stackoverflow.com/questions/18506456/git-how-to-delete-a-local-ref-branch:">http://stackoverflow.com/questions/18506456/git-how-to-delete-a-local-ref-branch:</a>
```</p>

<h1>Remove local ref</h1>

<p>git update-ref -d refs/remotes/origins/foo
```</p>

<h3>Ref log</h3>

<p><code>
git reflog
</code></p>

<h3>Remote</h3>

<p>```</p>

<h1>Remove origin</h1>

<p>git remote rm origin
git remote add origin git@donny:etagout.git
git remote show origin
```</p>

<h3>Remote Branch</h3>

<p>```</p>

<h1>Create branch. Reference: <a href="http://git-scm.com/book/en/Git-Branching-Remote-Branches">http://git-scm.com/book/en/Git-Branching-Remote-Branches</a></h1>

<p>git branch <branch></p>

<h1>Show local branches configured for push/pull, i.e. tracking branches</h1>

<p>git remote show origin
git push <remote> <branch></p>

<h1>Ex: git push origin foo</h1>

<h1>or</h1>

<p>git push <remote> &lt;local_branch>:<branch></p>

<h1>Ex: git push origin foo:bar</h1>

<p>```</p>

<h3>Tracking branch</h3>

<h4>Creating a new tracking branch</h4>

<p>```
git checkout -b &lt;local_branch> <remote>/<branch></p>

<h1>Ex:</h1>

<h1>git checkout -b foo origin/foo</h1>

<h1>git checkout -b bar origin/foo # local branch has a different name</h1>

<h1>Alternative:</h1>

<p>git checkout &mdash;track origin/foo</p>

<h1>Local branch has a different name</h1>

<p>git checkout -b bar &mdash;track origin/foo</p>

<h1>Within a tracking branch, push and pull automatically knows which server and branch to push to/pull from</h1>

<p>git pull
git push
```</p>

<h4>Setting up tracking information for an existing branch</h4>

<p>```
git branch &mdash;set-upstream <remote>/<branch> &lt;local_branch></p>

<h1>or</h1>

<p>git branch -u <remote>/<branch> &lt;local_branch></p>

<h1>Ex:</h1>

<h1>git branch -u origin/foo # when within branch foo</h1>

<h1>git branch -u origin/foo foo # when not within branch foo</h1>

<h1>Pull branch</h1>

<p>git pull <remote> <branch></p>

<h1>Delete branch</h1>

<p>git push <remote> :<branch>
```</p>

<h4>Pruning stale remote branches</h4>

<p>```
git remote show origin</p>

<pre><code>master    tracked
refs/remotes/origin/fix        stale (use 'git remote prune' to remove)
refs/remotes/origin/story_5008 stale (use 'git remote prune' to remove)
</code></pre>

<h1>Simulate deleting stale branches</h1>

<p>git remote prune origin &mdash;dry-run</p>

<h1>Actually delete stale branches</h1>

<p>git remote prune origin
```</p>

<h3>Commit</h3>

<p>```</p>

<h1>Switch to my branch</h1>

<p>git checkout <branch>
git status</p>

<h1>View diff per file</h1>

<p>git difftool</p>

<h1>Add all files in to staging area</h1>

<p>git add .
git status</p>

<h1>Commit to local repository</h1>

<p>git commit</p>

<h1>Switch to master</h1>

<p>git checkout master</p>

<h1>Pull down master updates</h1>

<p>git pull origin master
git checkout <branch></p>

<h1>Rewind my branch, pull down master updates, then add my update on top</h1>

<p>git rebase master
git checkout master</p>

<h1>Merge my update back to local master</h1>

<p>git merge <branch></p>

<h1>Pull down updates that occurred on canonical repository in the meantime</h1>

<p>git pull origin master</p>

<h1>Push local updates to canonical repository</h1>

<p>git push origin master
git log
```</p>

<h3>Reset</h3>

<p>```</p>

<h1>Changes after specified revision show up as uncommitted</h1>

<p>git reset SHA</p>

<h1>Changes after specified revision do not show up</h1>

<p>git reset SHA</p>

<h1>Unstage</h1>

<p>git reset HEAD <file></p>

<h1>Jump to 1 commit below HEAD, rolling back previous commit</h1>

<p>git reset HEAD~1</p>

<h1>Reset everything to HEAD, overwriting local changes&hellip;caution!</h1>

<p>git reset &mdash;hard HEAD
```</p>

<h3>Show</h3>

<p>```</p>

<h1>View diff</h1>

<p>git show SHA</p>

<h1>View content of file</h1>

<p>git show SHA:file
```</p>

<h3>Filing away local changes</h3>

<p>Create a new branch and commit the desired changes to it:</p>

<p><code>
git branch &lt;branch&gt;
git checkout &lt;branch&gt;
git add &lt;files&gt;...
git commit
</code></p>

<p>Merging origin changes with local changes:</p>

<p>```
git checkout <branch>
git add <file>
git commit
git checkout master
git pull origin master
git checkout <branch>
git rebase master</p>

<h1>Resolve conflicts</h1>

<p>git rebase &mdash;continue</p>

<h1>Roll back your commit</h1>

<p>git reset HEAD~1
```</p>

<p>Better:</p>

<p><code>
git checkout &lt;branch&gt;
git stash
git checkout master
git pull origin master
git checkout &lt;branch&gt;
git rebase master
git stash pop
</code></p>

<h3>Merging multiple branches</h3>

<pre><code>Branch 2
|
Branch 1 (committed)
|
master
</code></pre>

<p>```
git commit
git checkout branch1
git merge branch2</p>

<h1>Pick one commit and stash the other, then edit aggregate comment for both commits from the previous branch1 and branch2 comments</h1>

<p>git rebase -i master
git co master</p>

<h1>Merge aggregate commits into master</h1>

<p>git merge branch1</p>

<h1>Should see aggregate comment</h1>

<p>git log
```</p>

<h3>Tag</h3>

<p>```</p>

<h1>Check out a tag</h1>

<p>git checkout 2011-09-16</p>

<h1>Make sure your local master contains EXACTLY what you want tagged &mdash; &ldquo;git log&rdquo; to double check</h1>

<p>git checkout master</p>

<h1>Create a tag</h1>

<p>git tag -a &ldquo;tag name&rdquo;</p>

<h1>This removes the tag from your local master</h1>

<p>git tag -d &ldquo;tag name&rdquo;</p>

<h1>DANGER &ndash; the colon tells git to DELETE something &mdash; without a confirm prompt ! &mdash; here, we&rsquo;re deleting the remote master&rsquo;s tag</h1>

<p>git push origin :&ldquo;tag name&rdquo;</p>

<h1>This creates the tag on your local master</h1>

<p>git tag &ldquo;tag name&rdquo;</p>

<h1>This pushes the new tag back onto remote master</h1>

<p>git push &mdash;tags</p>

<h1>List tags</h1>

<p>git tag</p>

<h1>Fetch all tags</h1>

<p>git fetch &mdash;tags
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Angular root scope for communication between controllers]]></title>
    <link href="http://dinhyen.github.io/blog/2013/12/07/using-angular-root-scope-for-communication-between-controllers/"/>
    <updated>2013-12-07T13:28:00-05:00</updated>
    <id>http://dinhyen.github.io/blog/2013/12/07/using-angular-root-scope-for-communication-between-controllers</id>
    <content type="html"><![CDATA[<p>Angular makes it simple to create standard index and details views.  Using the ubiquitous task list as an example, I can set up routes using the <code>$route</code> service as follows:</p>

<p><code>javascript
$routeProvider
  .when('/tasks', { templateUrl: '_tasks.html', controller: 'TasksIndexCtrl' })
  .when('/task/:id', { templateUrl: '_task.html', controller: 'TaskDetailsCtrl' })
  .otherwise({ redirectTo: '/tasks' });
}
</code></p>

<p>The routes definitions specify the Angular controller and HTML template to use when the user navigates to a particular path.  Here we have 2 controllers, one for the index page and one for the details page.</p>

<p>The index controller retrieves the task list as a JSON array via the <code>$http</code> service:
``` javascript
function ($scope, $http) {
  $http.get(&lsquo;tasks.json&rsquo;).success(</p>

<pre><code>function (data) {
  $scope.tasks = data;
}
</code></pre>

<p>  );
}
```</p>

<p>The index view renders each task with a link which embeds the task&rsquo;s id.  When clicked, the link redirects to the task&rsquo;s details view.

<code>html
&lt;a href='#/task/{{task.id}}'&gt;{{task.name}}&lt;/a&gt;
</code>
</p>

<p>The details controller also retrieves task data as JSON via <code>$http</code>, after extracting the id value from <code>$routeParams</code>.
``` javascript
function ($scope, $http, $routeParams) {
  $http.get(&lsquo;task-&rsquo; + $routeParams.id + &lsquo;.json&rsquo;).success(</p>

<pre><code>function (data) {
  $scope.task = data;
}
</code></pre>

<p>  );
}
```</p>

<p><a href="http://embed.plnkr.co/CzbeallomRCE4HuVWtzO/preview" target="_blank">View the first version in Plunker</a></p>

<p>So far it&rsquo;s pretty run-of-the-mill.  But let&rsquo;s say the task list also contains sufficient data to show each task&rsquo;s details (the index page simply displays fewer information due to space constraint).  There&rsquo;d be no need for a separate request to pull data for the details page.  The details controller can just search in-memory, within the task list which is already retrieved.  However, since each controller has its own scope and can&rsquo;t access another&rsquo;s scope, there has to be another way to share data between controllers.</p>

<p>Enters the <a href="http://docs.angularjs.org/guide/scope">root scope</a>, which acts as the parent scope for all other scopes.  If a property can&rsquo;t be found in a scope, Angular searchs its parent scope and so on until it reaches the root scope (as a consequence of prototypical inheritance).  Putting the task list in the root scope would allow Angular to find it in the index controller and, because all scopes share the same root scope, also allow the details controller to access it.</p>

<p>Modifying the index controller to save the task list to the root scope:
``` javascript
function ($rootScope, $http) {
  $rootScope.tasks = [];
  $http.get(&lsquo;tasks.json&rsquo;).success(</p>

<pre><code>function (data) {
  $rootScope.tasks = data;
}
</code></pre>

<p>  );
}
```</p>

<p>Instead of making an HTTP request, the details controller can search for a task by id within the root scope.  When it finds the tasks, it saves it to its own scope.  It&rsquo;s probably a good idea to not pollute the root scope any more than necessary.
``` javascript
function ($rootScope, $scope, $routeParams) {
  var getTask = function (id) {</p>

<pre><code>id = parseInt(id, 10);
for (var i = 0; task = $rootScope.tasks[i]; ++i) {
  if (task.id === id) {
    return task;
  }
}
return task;
</code></pre>

<p>  };</p>

<p>  $scope.task = getTask($routeParams.id);
}
```</p>

<p>Each time the user returns to the index page, a fresh request is made to retrieve the task list.  I could optimize it further by retrieving the task list only if it has changed.  To do so, I&rsquo;d need to keep track of the modification time.  Here, I&rsquo;m only making the simple check to see whether the task list has already been populated.</p>

<p>``` javascript
function ($rootScope, $http) {
  if (typeof $rootScope.tasks === &lsquo;undefined&rsquo;) {</p>

<pre><code>$rootScope.tasks = [];
$http.get('tasks.json').success(
  function (data) {
    $rootScope.tasks = data;
  }
);
</code></pre>

<p>  }
}
```</p>

<p><a href="http://embed.plnkr.co/BwEtA3Ftp9SJ0OJCPHyv/preview" target="_blank">View the second version in Plunker</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Updating SQL Server Primary Key]]></title>
    <link href="http://dinhyen.github.io/blog/2013/11/23/updating-sql-server-primary-key/"/>
    <updated>2013-11-23T16:34:00-05:00</updated>
    <id>http://dinhyen.github.io/blog/2013/11/23/updating-sql-server-primary-key</id>
    <content type="html"><![CDATA[<p>A requirement recently came up to update the primary key of a SQL Server table.  We get user data from a third-party single sign-on service and store them locally.  When the SSO software was upgraded, user IDs were changed, so we need to update our local users but retain existing data.  I suppose one way to do so would be to drop any existing foreign-key constraint and update all related tables.  Unfortunately, the User table is related to practically every other table in the schema. Updating a bunch tables manually, without the safety net of relational integrity, would be a bit dodgy. Fortunately, there&rsquo;s a less painful approach using the <a href="http://technet.microsoft.com/en-us/library/ms186973.aspx">ON UPDATE CASCADE</a> clause.</p>

<p>In a simple example, I have a LineItem table, whose <code>userId</code> field references User&rsquo;s <code>Id</code> field. Since the existing FK relationship doesn&rsquo;t have ON DELETE CASCADE, I&rsquo;d have to &ldquo;alter&rdquo; the constraint to add it.  But because is no &ldquo;alter contraint&rdquo; in T-SQL, I&rsquo;d have to drop and re-add the constraint.</p>

<p>``` sql
/<em> drop existing constraint </em>/
ALTER TABLE [dbo].[LineItem] DROP CONSTRAINT [FK_LineItem_User]
GO</p>

<p>/<em> add constraint </em>/
ALTER TABLE [dbo].[LineItem]  WITH CHECK ADD  CONSTRAINT [FK_LineItem_User] FOREIGN KEY([UserId])
REFERENCES [dbo].[User] ([Id])
ON UPDATE CASCADE
GO</p>

<p>ALTER TABLE [dbo].[LineItem] CHECK CONSTRAINT [FK_LineItem_User]
GO
```</p>

<p>Thereafter when I update an Id in the User table, the change would be cascaded to LineItem and all other related tables.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[So long WordPress, hello Octopress]]></title>
    <link href="http://dinhyen.github.io/blog/2013/11/18/so-long-wordpress-hello-octopress/"/>
    <updated>2013-11-18T00:00:00-05:00</updated>
    <id>http://dinhyen.github.io/blog/2013/11/18/so-long-wordpress-hello-octopress</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been using WordPress since 2011.  It works well enough, but for me there are a few drawbacks.</p>

<ul>
<li><p>It&rsquo;s slow. It takes time to do anything from creating a post to previewing to deploying it.  I prefer to edit text in a proper text editor, with the full array of keyboard shortcuts, so I usually end up copying and pasting anyways.  But using the UI to do everything is cumbersome.  Of course I could install a local instance of WordPress so I can preview locally.  However, I would have to deploy everything, posts and images, every time. This seems inefficient for just adding a new post.</p></li>
<li><p>It&rsquo;s hard to backup.  I could export the WordPress content as an XML file, but this is only useful to WordPress.  For a full manual backup, I would use Control Panel to export the database, then FTP into the site and download the entire WordPress content folder as an archive.  This is time-consuming and a far cry from proper version control.</p></li>
<li><p>It&rsquo;s hard to customize.  There are probably a dozen plugins for anything I will ever want to do.  While I could view and edit the plugin source, without an easy way to test it&rsquo;s effectively a blackbox.  Further, I wouldn&rsquo;t want to have deal with PHP just to customize a plugin.</p></li>
</ul>


<p>So it&rsquo;s an easy to decision to put WordPress out to pasture.  I looked at Jekyll and deploying on Heroku. Jekyll seems like a good choice because it&rsquo;s used by GitHub, so it&rsquo;s more likely to be developed and less likely to go away.  I also checked out <a href="http://ruhoh.org">Ruhoh</a>, which is created by a Jekyll developer to address some of its shortcomings.  I really liked Ruhoh for the customizability, <a href="http://mustache.github.io">Mustache</a> markup syntax and incremental page generation.  I may go back to Ruhoh at some point.  I finally settled on Octopress.  It adds a theming engine and a host of productivity enhancements to Jekyll as well as beautiful syntax highlighting.  It makes it trivially simple to deploy to GitHub Pages.</p>

<p>There are many good articles written about using Octopress.  The <a href="http://octopress.org/docs">documentation</a>, for one, is a very good place to start.  Here are just some of the issues I ran into along the way.</p>

<h3>Importing from WordPress</h3>

<p>I used Jekyll&rsquo;s <a href="http://jekyllrb.com/docs/migrations">migration tools</a>, specifically <code>hpricot</code> to process a WordPress export XML file to generate posts and pages.  The process worked quite well, although as expected some manual cleanups were necessary.</p>

<h3>Setting up DNS</h3>

<p>This is probably a no-brainer for many people, unfortunately I&rsquo;m not among them.  Since my blog is now hosted by GitHub Pages, I had to configure my DNS to point my domain to the new IP address.  The process is quite clearly laid out in the <a href="https://help.github.com/articles/setting-up-a-custom-domain-with-pages">documentation</a>.  In my case, I had to create an <em>A record</em> for my top-level domain, <code>yentran.org</code>, to point to <code>204.232.175.78</code>.  I also created a CNAME record for the subdomain <code>www.yentran.org</code> as an alias which points to the same address.  I was concerned that my email address <code>xxx@yentran.org</code> would be broken.  It turns not to be the case.  Email forwarding relies on a MX record, which continues to point to my ISP&rsquo;s IP address.  There&rsquo;s also a wildcard record, which catches any unknown subdomain for which there is no matching A or CNAME record.</p>

<h3>Images</h3>

<p>Previously I used NextGen gallery to manage images.  NextGen stores images in separate folders, so it&rsquo;s simple to copy them (rather than searching for them on my hard drive).</p>

<p>I now use Dropbox&rsquo;s Public folder to host images.  This allows me to easily manage images.  In Lightroom (or any other image organizing software), I can export the images directly to Dropbox&rsquo;s local sync folder and the images immediately becomes available for linking.  If I want to modify images&mdash;such as resizing them&mdash;I can work directly with the Dropbox sync folder without having to make changes to the site.</p>

<h3>Image gallery</h3>

<p>I used Lightbox 2 jQuery plugin to display an image gallery.  However, it doesn&rsquo;t work with hotlinked images.  I decided to <a href="https://github.com/dinhyen/darkbox">roll my own</a>.</p>

<p>I wrote a small Ruby + <a href="http://whatisthor.com">Thor</a> utility to generate the necessary markup for images based on the Dropbox folder  and append it to posts.  Thor is awesome.</p>

<h3>Blogging with Octopress</h3>

<p>Everytime you add or modify a post or page, Jekyll regenerates the entire site.  This is so that it can properly update the site metadata.  However, this can take a long time, particularly if you have many posts and pages.  Octopress provides a useful optimization tool.  Type <code>rake isolate["post name"]</code> moves all other posts except the specified post into a _stash folder, so that regeneration is significantly faster.  Once you&rsquo;re done, type <code>rake integrate</code> to move the other posts back; just don&rsquo;t forget to do this before deploying.</p>

<h3>Categories</h3>

<p>Octopress doesn&rsquo;t provide an out-of-the-box way to display categories, but this can be easily done. I want display them as an aside (Octopress-speak for a sidebar plugin or partial).  I based mine on Octostrap3&rsquo;s <a href="http://kaworu.github.io/octopress/blog/2013/10/03/category-list-aside">Category List aside</a>.

``` html
<section>
  <h1>Categories</h1>
  <ul id="categories"></p>

<pre><code>{% for category in site.categories %}
 {% capture category_url %}{{ site.category_dir }}/{{ category | first | slugize | downcase | replace:' ','-' }}{% endcapture %}
  &lt;li data-category="{{ category | first }}"&gt;
    &lt;a href="{{ root_url | append:'/' | append:category_url }}"&gt;{{ category | first }}&lt;/a&gt; &lt;em&gt;{{ category | last | size }}&lt;/em&gt;
  &lt;/li&gt;
{% endfor %}
</code></pre>

<p>  </ul>
</section>
```
</p>

<p>Each category in the <code>site.categories</code> collection is an array, the first element being the category name and the last containing the pages in the category.  Unfortunately Jekyll&rsquo;s Liquid markup language doesn&rsquo;t have a way to sort a collection of arrays.  I opted to use JavaScript. This isn&rsquo;t ideal, but some of Octopress&rsquo;s own asides use the same approach.</p>

<p>``` javascript
$(function() {
  var categories = [];
  $(&lsquo;[data-category]&rsquo;).each(function() {</p>

<pre><code>categories.push(this);
</code></pre>

<p>  });
  categories.sort(function (a, b) {</p>

<pre><code>return a.attributes['data-category'].value.toLowerCase() &lt;= b.attributes['data-category'].value.toLowerCase()
      ? -1 : 1;
</code></pre>

<p>  });
  $(&lsquo;#categories&rsquo;).html(categories);
});
```</p>

<h3>Breadcrumbs</h3>

<p>This would be another nice-to-have for Octopress.  There are a few solutions to display breadcrumbs using Liquid.  However, the more I work with Liquid, the less I like it.  I would much prefer Mustache.  So I again went with a JavaScript solution, which would still work if later on I decide to go with another blogging framework.</p>

<p>``` javascript
function breadcrumbs() {
  var url_parts, $html, $li, $content, href, text, url, i;</p>

<p>  url = window.location.pathname;
  url_parts = $.grep(url.replace(/index.html/, &lsquo;&rsquo;).split(/\//), function (x) { return x.length > 0; });</p>

<p>  if (url_parts.length === 1) { // if at the top level</p>

<pre><code>return;
</code></pre>

<p>  }</p>

<p>  $html = $(&lsquo;<ol class="breadcrumbs">&rsquo;);
  for (i = 0; i &lt; url_parts.length; ++i) {</p>

<pre><code>text = url_parts[i];
href = 'http://dinhyen.github.io/' + url_parts.slice(0, i + 1).join('/');
$content = (i &lt; url_parts.length - 1) ? $('&lt;a&gt;').prop('href', href).text(text) : text;
$('&lt;li&gt;').append($content).appendTo($html);
</code></pre>

<p>  }
  $html.insertAfter(&lsquo;#breadcrumbs-js&rsquo;);
}</p>

<p>$(function () {
  breadcrumbs();
});
```</p>

<p>Here&rsquo;s the CSS:</p>

<p>``` css
.breadcrumbs {
  font-family: PT Sans, helvetica, sans-serif, arial;
  margin: 0;
  padding: 30px 15px 0 55px;
}
.breadcrumbs li {
  display: inline;
  list-style: none;
  padding-left: 15px;
}
.breadcrumbs li:not(:last-child):after {
  padding-left: 15px;
  content: &ldquo;/&rdquo;;
}
.breadcrumbs li:first-child {
  padding-left: 0;
}
/<em> Octopress classic theme </em>/</p>

<h1>content .breadcrumbs + div > {</h1>

<p>  margin-top: 15px;
}</p>

<h1>content .breadcrumbs + div > article > header {</h1>

<p>  padding-top: 0;
}
```</p>

<p>I created a partial consisting of the JavaScript and the necessary CSS, then included it in the <code>pages.html</code> layout.</p>

<p>
<code>
{% render_partial _includes/custom/breadcrumbs.html %}
</code>
</p>

<h3>Navigation</h3>

<p>On my <a href="/travel">travel pages</a>, I want to have a hierarchy of links to different destinations:</p>

<pre><code>USA
  Arizona
    Grand Canyon National Park
  Florida
    Cape Canaveral
</code></pre>

<p>It should be set up so that if I add a new destination, I wouldn&rsquo;t have to hunt down all the pages containing the links in order add a new one.  Luckily, with Jekyll all of the site&rsquo;s metadata is stored in a single YAML file and accessible through the <code>site</code> variable.  In order to capture the navigation hierarchy, I added the following to <code>_config.yml</code>:</p>

<pre><code>travel:
  usa:
    - name: "Arizona"
      url:  az
      places:
        - name: "Grand Canyon National Park"
          url:  grand-canyon-national-park
    - name: "Florida"
      url:  fl
      places:
        - name: "Cape Canaveral"
          url:  cape-canaveral
</code></pre>

<p><a href="http://www.yaml.org">YAML</a> is a really compact, highly readable format.  In the block above, indentation denotes nesting, <code>:</code> denotes a key-value pair and <code>-</code> denotes a collection.  The parser turns the above YAML into the following hash:
```
{
  &ldquo;travel&rdquo; => {</p>

<pre><code>"usa" =&gt; [
  {
    "name" =&gt; "Arizona", "url" =&gt; "az", "places" =&gt; [
      {"name" =&gt; "Grand Canyon National Park", "url" =&gt; "grand-canyon-national-park"}
    ]
  }, 
  {
    "name" =&gt; "Florida", "url" =&gt; "fl", "places" =&gt; [
      {"name" =&gt; "Cape Canaveral", "url" =&gt; "cape-canaveral"}
    ]
  }
]
</code></pre>

<p>  }
}
<code>``
After making modifications to</code>_config.yml<code>, I could quickly examine them by firing up the interactive Ruby shell,</code>irb`, then typing the following:</p>

<p><code>
require 'yaml'
site = YAML.load_file('_config.yml')
</code></p>

<p>I can access the navigation metadata as follows:</p>

<ul>
<li><code>site["travel"]</code> returns a hash containing country objects</li>
<li><code>site["travel"]["usa"]</code> returns an array of state objects</li>
<li><code>site["travel"]["usa"][0]</code> returns the first element of the array, which is Arizona</li>
<li><code>site["travel"]["usa"][0]["name"]</code> returns the text &ldquo;Arizona&rdquo; and <code>site["travel"]["usa"][0]["url"]</code> the corresponding URL</li>
<li><code>site["travel"]["usa"][0]["places"]</code> returns an array of locations in Arizona</li>
<li><code>site["travel"]["usa"][0]["places"][0]</code> returns the object for Grand Canyon National Park, and so on</li>
</ul>


<p>Jekyll makes it even nicer to work with the hash by turning keys into instance methods.  So instead of writing <code>site["travel"]["usa"][0]["places"][0]</code>, I could also write <code>site.travel.usa[0].places[0]</code>.</p>

<p>In order to generate the following HTML for the navigation:</p>

<p>``` html</p>

<ul>
  <li><a href="http://dinhyen.github.io/travel/usa">USA</a>
    <ul>
      <li><a href="http://dinhyen.github.io/travel/usa/az">Arizona</a>
        <ul>
          <li><a href="http://dinhyen.github.io/travel/usa/az/grand-canyon-national-park">Grand Canyon National Park</a></li>
        </ul>
      </li>
      <li><a href="http://dinhyen.github.io/travel/usa/fl">Florida</a>
        <ul>
          <li><a href="http://dinhyen.github.io/travel/usa/fl/cape-canaveral">Cape Canaveral</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>


<p>```</p>

<p>I used the following Liquid code:

``` html</p>

<ul>
  <li><a href="{{ root_url }}/travel/usa">USA</a>
    <ul>
      {% for state in site.travel.usa %}
        <li><a href="{{ root_url }}/travel/usa/{{ state.url }}">{{ state.name }}</a>
          <ul>
            {% for place in state.places %}
              <li><a href="{{ root_url }}/travel/usa/{{ state.url }}/{{ place.url }}">{{ place.name }}</a></li>
            {% endfor %}
          </ul>
        </li>
      {% endfor %}
    </ul>
  </li>
</ul>


<p>```
</p>

<p>Now if I want to add another destination, I&rsquo;d only have to modify the YAML.</p>

<h3>Conclusion</h3>

<p>Octopress/Jekyll makes it easy and fun to tweak, hack and do so efficiently. I only wish I&rsquo;d made the switch earlier!</p>
]]></content>
  </entry>
  
</feed>
